const { readdirSync, readFileSync, writeFileSync, statSync } = require("fs");
const { join, extname, basename } = require("path");
const { marked } = require("marked");
const mime = require("mime-types");

const EXAMPLES_PATH = join(__dirname, "..", "..", "examples");

const PRIVATE_EXAMPLES_DIR_NAMES = require("../../examples.config").private;

const PAGES_PATH = join(__dirname, "..", "pages");
const EXAMPLES_OUTPUT_PATH = join(__dirname, "..", "examples.js");
const EXAMPLES_FILE_SYSTEM_PATHS = readdirSync(EXAMPLES_PATH).filter((f) =>
  statSync(join(EXAMPLES_PATH, f)).isDirectory()
);
const AUTOMATICALLY_GENERATED_HEADER = `/**
* THIS FILE IS AUTOMATICALLY GENERATED.
*/`;

function generatePages() {
  EXAMPLES_FILE_SYSTEM_PATHS.forEach(generatePage);
}

function generateExamplesIndex() {
  const exampleIndex = parseExamples();

  const content = `${AUTOMATICALLY_GENERATED_HEADER}

export default ${JSON.stringify(exampleIndex, null, 2)};
`;

  writeFileSync(EXAMPLES_OUTPUT_PATH, content);
}

function parseExamples() {
  return EXAMPLES_FILE_SYSTEM_PATHS.map(parseExample);
}

function generatePage(fileSystemPath) {
  const { title, name, fileInfo } = parseExample(fileSystemPath);

  const content = `${AUTOMATICALLY_GENERATED_HEADER}

import * as hooks from "../../examples/${fileSystemPath}";
import Example from "../components/example/show";

const ${componentCase(name)} = (props) => (
  <Example
    key="${name}"
    name="${name}"
    fileName="${fileInfo.name}"
    title="${title}"
    hooks={hooks}
    {...props}
  />
);
export default ${componentCase(name)};
`;

  writeFileSync(join(PAGES_PATH, `${name}.js`), content);
}

function parseExample(fileSystemPath) {
  const [title, description] =
    extractTitleAndDescriptionFromReadme(fileSystemPath);

  let pathSegments = fileSystemPath.split("-");

  pathSegments.shift();

  const name = pathSegments.join("-");

  const dirname = join(EXAMPLES_PATH, fileSystemPath);

  let icon = null;

  try {
    icon = readFileSync(join(dirname, "icon.svg")).toString();
  } catch (e) {
    // No-op
  }

  let fileInfo = null;

  readdirSync(dirname).some((file) => {
    const ext = extname(file);
    const filename = basename(file, ext);

    if (filename === "example") {
      fileInfo = {
        name: filename + ext,
        mimeType: mime.lookup(ext),
      };

      return true;
    }

    return false;
  });

  if (!fileInfo) {
    throw new Error("Could not find an example document for " + dirname);
  }

  const isPublic =
    process.env.NODE_ENV !== "production" ||
    !PRIVATE_EXAMPLES_DIR_NAMES.includes(fileSystemPath);

  return {
    name,
    title,
    description,
    fileSystemPath,
    icon,
    fileInfo,
    isPrivate: isPublic ? undefined : true,
  };
}

// Extract title and description from README.md
// Supports only one heading and one paragraph
function extractTitleAndDescriptionFromReadme(fileSystemPath) {
  const markdownTree = marked.lexer(
    readFileSync(join(EXAMPLES_PATH, fileSystemPath, "README.md")).toString()
  );

  const titleToken = markdownTree.find((token) => token.type === "heading");

  if (!titleToken) {
    throw new Error("No title found in README.md for " + fileSystemPath);
  }

  const contentToken = markdownTree.find((token) => token.type === "paragraph");

  if (!contentToken) {
    throw new Error("No content found in README.md for " + fileSystemPath);
  }

  return [titleToken.text, contentToken.text];
}

module.exports = {
  generatePages,
  generateExamplesIndex,
  parseExamples,
};

const componentCase = (value) => {
  const val = value.replace(/[-_\s.]+(.)?/g, (_match, chr) =>
    chr ? chr.toUpperCase() : ""
  );

  return val.slice(0, 1).toUpperCase() + val.slice(1);
};
